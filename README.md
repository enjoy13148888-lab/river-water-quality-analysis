# river-water-quality-analysis
1. User Input Validation: Water Quality Report
To check if the year and river name that a user types in are in the raw data, The implementation began by asking an AI (Perplexity) to help me write a function for the year part. Since the tasks were similar, I then modified that function to work for the river part as well.
For the year part, I first thought about making an empty list to hold the years. But Perplexity suggested that it would be better to use an empty set. This makes the code run faster and prevents duplicate years from being added. The data read from the CSV file is returned as a list of tuples, where each tuple represents one row of data. Then, using the datetime.strptime() function to turn the string into a date object. By using a try-except block, the program can handle errors gracefully without crashing, which makes the input process more reliable. The converted object is then broken down to extract the year, which is saved to the set(). In the end, the function returns a sorted list of all unique years.
The idea for the river part is similar. The only difference is that using an if and strip() function to stop empty spaces or blank lines from getting into the set.
In the “main” function, using a “while True” loop. The main reason for this is to make sure the user types in the right information. If they make a mistake, an error message, likely” river names not found in the data.” shows up and asks them to try again until they get it right.

2. Include Count, High, and Low Readings: Water Quality Report
I updated my water quality report function instead of creating a new one, so that it could show more details. First, I changed the top line of the report to include Count, High, Low, and Avg. This makes the output much clearer, because you can see all the important numbers easily. I did this by adding print("Name Count High Low Avg"), which shows all the needed columns in the output. To make it easier for the user to read, I used f-strings with fixed widths so that the titles and outputs line up neatly.
In the beginning, I set the starting values for high and low to 0, but I found this caused
problems when the data had negative values, because with 0 as a starting point the program might never update the maximum or minimum correctly. To fix this, I asked AI for help, and then I learned that using None is better. It means “no value yet,” so the first matching reading will automatically set both high and low.
In order to find highest and lowest. I used if high is None or reading > high: to update the highest reading, and if low is None or reading < low: to update the lowest reading. I also kept the average value calculation from before because it adds more useful statistical information and keeps the results consistent with previous output.
Based on AI's suggestion, a very important change I made was to add a check so that if there is no data for the river in that year, the program prints "N/A" for all values. This is important because it stops the program from crashing and makes the Water Quality Report more complete, more reliable, and easier to understand for anyone reading the output.

3. Warn the User if No Records Found
In order to warn the user when there is no data available, I added a boolean variable named found_any in the water quality report part. This variable is used to check if any data matching the criteria has been found. At the start, I set found_any to False, meaning no data has been found yet. The function searches data for each river specified by the user, and when it finds matching records, it sets found_any to True. After all selected rivers are processed, if found_any is still False, it means no records match the search criteria, so the program prints a warning message to notify the user that no data was found.
Using a simple boolean variable makes the whole checking process much cleaner and easier to follow. Instead of printing warnings or updating a status at every single step, we just use a single true/false "flag" to keep track of any issues. This approach is more reliable because the final warning is only printed once at the very end, which helps prevent a series of confusing messages and greatly reduces the chance of errors in the program.
At first, I mistakenly set the initial value of found_any to True. However, because later code uses the condition if count > 0:, the found_any variable remained True all the time, even when no data was actually found. After AI's correction, I changed the initial value to False so it correctly indicates whether matching data has been found or not. This change improved the program's accuracy and the user's experience by ensuring the
warning only appears when it is really needed.

4. Add all years: Water Quality Report
Because the original function only prints the water quality report for a single year, I need to write a new function to print all years' reports in order to complete the "add all years: water quality report" task.
In the new function called print_water_quality_report_all_years. At the start of the function, it calls another function called get_unique_years_from_csv to get all the unique years from the original CSV data file. This step is important because it tells the program which years have data available. The years returned are sorted from the earliest to the latest year. Sorting ensures that the reports are printed in the right order to make it easy to understand the progress over time. Then, the function uses a for loop to go through each year in the sorted list, one by one. For every year, it first prints the year itself as a title. This lets the user know clearly which year they are seeing the report for. It makes the output neat and organized, so users can follow the data year after year easily. Finally, I call the original water_quality_report function to generate the report for that specific year.
In the main program, the first step is to add a new menu option called "Water Quality Report - All Years" to the existing menu_options list. Next, I introduce a new elif statement in the control flow to handle the case when the user inputs "1". This allows the program to detect when the user wants to access the "Water Quality Report - All Years" functionality.
The new elif option == 1 block’s code is mostly copied from the existing elif option == 0 block for the single year report. The main change is calling the new print_water_quality_report_all_years function instead of the single-year one. This new function loops automatically through all years and prints reports one by one.

5. Line Graph of Water Quality Over Time
To draw a Line Graph, first import the matplotlib package. Then create a function called plot_water_quality_over_time to help me draw the graph. First, read the three variables "river", "sDate", and "values" from the CSV file. Next, with AI’s help, create a dictionary called river_dict to store, for each river, a list of water quality values for each year. Considering possible format errors, use try and except so the program can continue even if there are formatting problems. Then, with AI’s help, use setdefault to add the current water quality value to the list for that year. Before drawing the graph, calculate
the average water quality value for each year. After that, use matplotlib to plot the line graph. AI suggested adding plt.tight_layout() to automatically adjust the layout and prevent labels or axes from being cut off.
Next, in the main function under option 2, use a while loop to repeatedly prompt the user to enter a river name. The program will check if the entered name is valid by verifying it against the list of known rivers. If the input is invalid, an error message will be displayed and the user will be asked to try again. This loop will continue to run until the user provides a valid river name. Once a valid input is received, the program will call the function plot_water_quality_over_time, passing the entered river name as an argument to generate and display a line graph that shows how the water quality changes over time for that river.
